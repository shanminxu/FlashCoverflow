// Coverflow v1.0 by Heavenbrook, all rights reserved.// Flash CS4 and above.package cs4.effect {	import flash.display.Sprite;	import flash.display.Loader;	import flash.net.URLRequest;	import flash.events.MouseEvent;	import flash.events.Event;	import fl.motion.easing.*;	import flash.display.Bitmap;	import flash.geom.Matrix;	import flash.display.Shape;	import flash.display.GradientType;		import as3.tool.*;		public class Coverflow extends Sprite {		private var mc:Sprite = new Sprite();		private var arrLoader:Array = new Array();		private var arrImage:Array = new Array();		private var arrAnimate:Array = new Array();		private var arrSprite:Array = new Array();		private var animate:Animate = new Animate();		public var curImage:int=3, deltaX:Number=50;		private var imageW:Number=640, imageH:Number=480, deltaAngle:Number=11, imageAngle:Number=60;		private var mouse_down:Boolean = false;		private var oldX:Number;		private var curImage_save:int;		public var showReflection:Boolean = true;		public var showFrame:Boolean = true;				public function Coverflow(imageW:Number, imageH:Number):void {			this.imageW = imageW; this.imageH = imageH;			addChild(mc);			mc.addEventListener(MouseEvent.CLICK, mc_click);			mc.addEventListener(MouseEvent.MOUSE_DOWN, mc_down);			mc.addEventListener(MouseEvent.MOUSE_UP, mc_up);			mc.addEventListener(MouseEvent.MOUSE_MOVE, mc_move);			//root.transform.perspectiveProjection.fieldOfView = 50;		}				private function mc_down(e:MouseEvent):void {			mouse_down = true;			oldX = mouseX;		}				private function mc_up(e:MouseEvent):void {			mouse_down = false;		}				private function mc_move(e:MouseEvent):void {			if ( !mouse_down ) return;			if ( mouseX - oldX > 100 ) {				oldX = mouseX;				moveRight();			}			if ( mouseX - oldX < -100 ) {				oldX = mouseX;				moveLeft();			}		}				private function mc_click(e:MouseEvent):void {			var i:int, index:int;						index = e.target.name.substr(6);			/*if ( index < curImage ) {				for (i=index+1; i<=curImage; i++) arrAnimate[i].tween(arrLoader[i], 5, Linear.easeIn, arrLoader[i].x+imageW, 0, 1, 1, "rotationY", 90);				arrAnimate[index].tween(arrLoader[index], 5, Linear.easeIn, arrLoader[index].x, 0, 1, 1, "rotationY", 0);			}			if ( index > curImage ) {				arrAnimate[curImage].tween(arrLoader[curImage], 5, Linear.easeIn, arrLoader[curImage].x, 0, 1, 1, "rotationY", -90);				for (i=curImage+1; i<index; i++) arrAnimate[i].tween(arrLoader[i], 5, Linear.easeIn, arrLoader[i].x-imageW, 0, 1, 1, "rotationY", -90);				arrAnimate[index].tween(arrLoader[index], 5, Linear.easeIn, arrLoader[index].x-imageW, 0, 1, 1, "rotationY", 0);			}*/			//animate.tween(mc, 5, Linear.easeIn, mc.x, mc.y, 1, 1, "rotationY", index*deltaAngle);			//curImage = index;			if ( index == curImage ) dispatchEvent(new PubEvent("imageClick", {curImage:curImage}));		}				public function moveRight():void {			if ( curImage == 0 ) return;			arrAnimate[curImage].tween(arrSprite[curImage], 5, Linear.easeIn, curImage * deltaX + imageW, 0, 1, 1, "rotationY", 90);			arrSprite[curImage].getChildAt(1).alpha = 0.6;			arrSprite[curImage].getChildAt(1).scaleX = -1;			arrSprite[curImage].getChildAt(1).x = imageW/2;			curImage--;			arrAnimate[curImage].tween(arrSprite[curImage], 5, Linear.easeIn, curImage * deltaX + imageW/2, 0, 1, 1, "rotationY", 0);			arrSprite[curImage].getChildAt(1).alpha = 0;			sortZ();			animate.tween(mc, 5, Linear.easeIn, (curImage_save-curImage) * deltaX, mc.y, 1, 1);			dispatchEvent(new PubEvent("curImageChanged", {curImage:curImage}));			setAlpha();		}				public function moveLeft():void {			if ( curImage == arrImage.length-1 ) return;			arrAnimate[curImage].tween(arrSprite[curImage], 5, Linear.easeIn, curImage * deltaX, 0, 1, 1, "rotationY", -90);			arrSprite[curImage].getChildAt(1).alpha = 0.6;			arrSprite[curImage].getChildAt(1).scaleX = 1;			arrSprite[curImage].getChildAt(1).x = -imageW/2;			curImage++;			arrAnimate[curImage].tween(arrSprite[curImage], 5, Linear.easeIn, curImage * deltaX + imageW/2, 0, 1, 1, "rotationY", 0);			arrSprite[curImage].getChildAt(1).alpha = 0;			sortZ();			animate.tween(mc, 5, Linear.easeIn, (curImage_save-curImage) * deltaX, mc.y, 1, 1);			dispatchEvent(new PubEvent("curImageChanged", {curImage:curImage}));			setAlpha();		}				private function setAlpha():void {return;			var i:int;			for (i=0; i<curImage-5; i++) arrSprite[i].alpha = 0;			for (i=Math.min(curImage+5, arrSprite.length-1); i<arrSprite.length-1; i++) arrSprite[i].alpha = 0;			for (i=Math.max(0, curImage-5); i<curImage; i++) arrSprite[i].alpha = (5-curImage+i)/5;			for (i=Math.min(curImage+1, arrSprite.length-1); i<Math.min(curImage+5, arrSprite.length-1); i++) arrSprite[i].alpha = (5-i+curImage)/5;			arrSprite[curImage].alpha = 1;		}				private function sortZ():void {			var i:int;						for (i=0; i<curImage; i++) arrSprite[i].z = -i * 1 + imageW/2;			arrSprite[i].z = -i * 1 + imageW/2;			for (i=curImage+1; i<arrImage.length; i++) arrSprite[i].z = i * 1 + imageW/2;			SimpleZSorter.sortClips(mc);		}				public function addImage(filename:String):void {			arrImage.push(filename);		}				public function resize(w:Number, h:Number):void {		}				private function loader_complete(e:Event):void {			//imageW = e.target.loader.width; // not right, because it is rotated			//imageH = e.target.loader.height;			var index:int = e.target.loader.name.substr(6);			e.target.loader.content.x -= e.target.loader.width/2;						if ( showFrame ) {				var shape:Shape = new Shape();				//shape.graphics.beginFill(color);				shape.graphics.lineStyle(3, 0x888888);				shape.graphics.drawRect(-e.target.loader.width/2, 0, e.target.loader.width, e.target.loader.height);				//shape.graphics.endFill();				arrSprite[index].addChild(shape);			}						if ( showReflection ) {				var bmp:Bitmap = Bitmap(e.target.loader.content);				var reflectionBmp:Bitmap = new Bitmap(bmp.bitmapData.clone());				reflectionBmp.alpha = 1;								var matr:Matrix = new Matrix();				matr.createGradientBox(e.target.loader.width, e.target.loader.height, Math.PI/2, 0, 0);				var mc_gradient:Shape = new Shape();				mc_gradient.graphics.beginGradientFill(GradientType.LINEAR, [0xFFFFFF, 0xFFFFFF, 0xFFFFFF], [1, 0.8, 0.5], [0xA0, 0xD0, 0xFF], matr);            	mc_gradient.graphics.drawRect(-2, -2, e.target.loader.width+4, e.target.loader.height+2);            	mc_gradient.graphics.endFill();								var reflectionSprite:Sprite = new Sprite();				reflectionSprite.addChild(reflectionBmp);								if ( showFrame ) {					shape = new Shape();					shape.graphics.lineStyle(3, 0x888888);					shape.graphics.drawRect(0, 0, e.target.loader.width, e.target.loader.height);					reflectionSprite.addChild(shape);				}								reflectionSprite.addChild(mc_gradient);				reflectionSprite.scaleY = -1;				reflectionSprite.y = 2 * e.target.loader.height;				reflectionSprite.x = e.target.loader.content.x;				arrSprite[index].addChild(reflectionSprite);			}						if ( index < curImage ) arrSprite[index].rotationY = -90;			if ( index > curImage ) arrSprite[index].rotationY = 90;			arrSprite[index].getChildAt(1).visible = true;		}				public function refresh():void {			var i:int;			var gradientShadow:GradientShadow;						curImage_save = curImage;						for (i=0; i<curImage; i++) {				arrSprite[i] = new Sprite();								arrLoader[i] = new Loader();				arrLoader[i].name = "loader"+i;				arrLoader[i].load(new URLRequest(arrImage[i]));				arrLoader[i].contentLoaderInfo.addEventListener(Event.COMPLETE, loader_complete);				arrSprite[i].addChild(arrLoader[i]);								gradientShadow = new GradientShadow(imageW, imageH);				gradientShadow.alpha = 0.6;				gradientShadow.blendMode = "multiply";				gradientShadow.x = -imageW/2;				gradientShadow.visible = false;				arrSprite[i].addChild(gradientShadow);				arrSprite[i].x = i * deltaX;								mc.addChild(arrSprite[i]);				arrAnimate[i] = new Animate();			}						arrLoader[i] = new Loader();			arrLoader[i].name = "loader"+i;			arrLoader[i].load(new URLRequest(arrImage[i]));			arrLoader[i].contentLoaderInfo.addEventListener(Event.COMPLETE, loader_complete);			arrSprite[i] = new Sprite();			arrSprite[i].addChild(arrLoader[i]);			gradientShadow = new GradientShadow(imageW, imageH);			gradientShadow.alpha = 0;			gradientShadow.blendMode = "multiply";			gradientShadow.x = -imageW/2;			gradientShadow.visible = false;			arrSprite[i].addChild(gradientShadow);			arrSprite[i].x = i * deltaX + imageW/2;			mc.addChild(arrSprite[i]);			arrAnimate[i] = new Animate();			dispatchEvent(new PubEvent("curImageChanged", {curImage:i}));							for (i=curImage+1; i<arrImage.length; i++) {				arrLoader[i] = new Loader();				arrLoader[i].name = "loader"+i;				arrLoader[i].load(new URLRequest(arrImage[i]));				arrLoader[i].contentLoaderInfo.addEventListener(Event.COMPLETE, loader_complete);				arrSprite[i] = new Sprite();				arrSprite[i].addChild(arrLoader[i]);				gradientShadow = new GradientShadow(imageW, imageH);				gradientShadow.alpha = 0.6;				gradientShadow.blendMode = "multiply";				gradientShadow.x = imageW/2;				gradientShadow.scaleX = -1;				gradientShadow.visible = false;				arrSprite[i].addChild(gradientShadow);				arrSprite[i].x = i * deltaX + imageW;				mc.addChild(arrSprite[i]);				arrAnimate[i] = new Animate();			}						/*for (i=0; i<curImage; i++) {				arrLoader[i] = new Loader();				arrLoader[i].name = "loader"+i;				arrLoader[i].load(new URLRequest(arrImage[i]));				arrLoader[i].contentLoaderInfo.addEventListener(Event.COMPLETE, loader_complete);				arrLoader[i].rotationY = -90 -(i-5) * deltaAngle;				arrLoader[i].x = imageW * Math.sin((i-5) * deltaAngle*Math.PI/180);				arrLoader[i].z = -imageW * Math.cos((i-5) * deltaAngle*Math.PI/180) + 640;				mc.addChild(arrLoader[i]);				arrAnimate[i] = new Animate();			}			arrLoader[i] = new Loader();			arrLoader[i].name = "loader"+i;			arrLoader[i].load(new URLRequest(arrImage[i]));			arrLoader[i].contentLoaderInfo.addEventListener(Event.COMPLETE, loader_complete);			arrLoader[i].rotationY = 0;			arrLoader[i].x = imageW * Math.sin((i-3) * deltaAngle*Math.PI/180);			arrLoader[i].z = -imageW * Math.cos((i-3) * deltaAngle*Math.PI/180) + 640;			mc.addChild(arrLoader[i]);			arrAnimate[i] = new Animate();						for (i=curImage+1; i<arrImage.length; i++) {				arrLoader[i] = new Loader();				arrLoader[i].name = "loader"+i;				arrLoader[i].load(new URLRequest(arrImage[i]));				arrLoader[i].contentLoaderInfo.addEventListener(Event.COMPLETE, loader_complete);				arrLoader[i].rotationY = -90 -(i-1) * deltaAngle;				arrLoader[i].x = imageW * Math.sin((i-1) * deltaAngle*Math.PI/180);				arrLoader[i].z = -imageW * Math.cos((i-1) * deltaAngle*Math.PI/180) + 640;				mc.addChild(arrLoader[i]);				arrAnimate[i] = new Animate();			}*/						sortZ();			setAlpha();		}	}}import flash.display.Sprite;import flash.display.Graphics;import flash.display.GradientType;import flash.geom.Matrix;class GradientShadow extends Sprite {	public function GradientShadow(w:Number, h:Number) {		var matr:Matrix = new Matrix();		matr.createGradientBox(w, h, 0, 0, 0);		this.graphics.beginGradientFill(GradientType.LINEAR, [0xFFFFFF, 0x000000], [1, 1], [0x00, 0xFF], matr);        this.graphics.drawRect(0, 0, w, h);        this.graphics.endFill();		this.mouseEnabled = false;	}}